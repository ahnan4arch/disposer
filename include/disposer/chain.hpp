//-----------------------------------------------------------------------------
// Copyright (c) 2015-2017 Benjamin Buch
//
// https://github.com/bebuch/disposer
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt)
//-----------------------------------------------------------------------------
#ifndef _disposer__chain__hpp_INCLUDED_
#define _disposer__chain__hpp_INCLUDED_

#include "module_ptr.hpp"
#include "id_generator.hpp"
#include "log_base.hpp"
#include "log.hpp"


#include <mutex>
#include <string>
#include <vector>
#include <condition_variable>


namespace disposer{


	/// \brief A process chain
	///
	/// Properties:
	/// - no 2 identical modules (in different executions) must running
	///   simultaneously
	/// - it must not be overtaken
	class chain{
	public:
		/// \brief Construct a proccess chain
		///
		/// \param modules A list of modules
		/// \param generate_id Reference to a id_generator
		/// \param name The name of the proccess chain
		/// \param group A reference to the group name
		///
		/// The id increase for the id_generator is calculated over all modules.
		chain(
			std::vector< module_ptr >&& modules,
			id_generator& generate_id,
			std::string const& name,
			std::string const& group
		);

		chain(chain const&) = delete;
		chain(chain&&) = delete;

		chain& operator=(chain const&) = delete;
		chain& operator=(chain&&) = delete;


		/// \brief Execute the proccess chain
		///
		/// 1 A new id is generated by the id_generator.
		/// 2 The first module is executed
		/// 3.1 Outputs are mapped to inputs of later modules
		/// 3.2 Next module is executed
		/// 3.3 if not last module then back to 3.1
		///
		/// If a module throws an exception,
		void exec();


		/// \brief Name of the chain
		std::string const name;

		/// \brief Reference to the group name
		std::string const& group;


	private:
		/// \brief Handles the exec and the cleanup of a module
		template < typename F >
		void process_module(
			std::size_t const i,
			std::size_t const run,
			F const& action,
			char const* const action_name
		);


		/// \brief List of modules
		std::vector< module_ptr > const modules_;


		/// \brief Increase for the id_generator
		std::size_t const id_increase_;

		/// \brief Referenz to the id_generator
		id_generator& generate_id_;


		/// \brief Count of exec() calls
		std::atomic< std::size_t > next_run_;

		/// \brief One entry per module, value is the last run id
		///
		/// The run id is generated by next_run_ in exec()
		std::vector< std::size_t > ready_run_;


		/// \brief One mutex per module
		std::vector< std::mutex > mutexes_;

		/// \brief Manages the mutexes_
		std::condition_variable cv_;
	};


}


#endif
